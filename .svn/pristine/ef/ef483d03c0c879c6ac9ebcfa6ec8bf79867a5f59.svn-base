//抗拒火环
class CircleHitSkill extends SkillBase
{
    //获取技能目标列表
	protected getSkillTargetList(target:BlackboardComponent, sx:number, sy:number, tx:number, ty:number):List<BlackboardComponent>
    {
        return this.getTargetList(Utility.getCircleRangeByRadius(sx, sy, this.skillTp.range));
    }

	//释放技能
	public castSkill(target:Entity):List<DamageInfoEvent>
    {
        if (this.isCastSkill)
            return;

        var selfComp = this.owner.getComponent<BlackboardComponent>(ComponentType.Blackboard);       
        var targetComp = target.getComponent<BlackboardComponent>(ComponentType.Blackboard);

        this.skillConsume(selfComp);

        var damageInfoList = this.useSkill(selfComp, targetComp);
        if (!damageInfoList || damageInfoList.count == 0)
            return;

        var sx = selfComp.getAttrValue(data.RoleAttr.x);
        var sy = selfComp.getAttrValue(data.RoleAttr.y);

		var effectArgList = this.skillEffectArgumentsDic.getValue(SkillEffect.HitMove);
        if (!effectArgList || effectArgList.count == 0)
        {
            console.error("HitSkill castSkill effectArgList.count == 0");
            return;
        }

		damageInfoList.forEach(damageInfo =>
		{
			var targetBlackboard = damageInfo.who.getComponent<BlackboardComponent>(ComponentType.Blackboard);
			var tx = targetBlackboard.getAttrValue(data.RoleAttr.x);
        	var ty = targetBlackboard.getAttrValue(data.RoleAttr.y);

        	var targetPt = this.getHitMovePt(sx, sy, tx, ty, effectArgList[0]);
			damageInfo.hitPt.x = targetPt.x;
			damageInfo.hitPt.y = targetPt.y;

			ModuleEventMgr.instance.triger(new RoleMoveEvent(this.owner, new egret.Point(tx, ty), targetPt));
		});

		return damageInfoList;
    }

	//返回撞击目标点
    private getHitMovePt(sx:number, sy:number, tx:number, ty:number, distance:number):egret.Point
    {
        var vecX = tx - sx;
        var vecY = ty - sy;

        var distanceX = vecX < 0 ? -vecX : vecX;
        var distanceY = vecY < 0 ? -vecY : vecY;

        var targetPt = new egret.Point(sx, sy);

        //在斜线方向 以当前方向击退X格
        if (distanceX == distanceY)
        {
            for(let i = 1; i <= distance; i++)
            {
                let x = tx + (vecX < 0 ? -i : i);
                let y = ty + (vecY < 0 ? -i : i);

                if (MapModule.isBlock(x, y))
                    break;

                targetPt.x = x;
                targetPt.y = y;
            }
        }
        //由于斜线算1，所以有可能x的距离是2，y距离是1的情况，这时将以X方向击退
        else if (distanceY == 0)
        {
            for(let i = 1; i <= distance; i++)
            {
                let x = tx + (vecX < 0 ? -i : i);

                if (MapModule.isBlock(x, sy))
                    break;

                targetPt.x = x;
            }
        }
        //将以Y方向击退
        else
        {
            for(let i = 1; i <= distance; i++)
            {
                let y = ty + (vecY < 0 ? -i : i);

                if (MapModule.isBlock(sx, y))
                    break;

                targetPt.y = y;
            }
        }

        return targetPt;
    }
}